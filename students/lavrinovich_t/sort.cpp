#include <iostream>

using namespace std;

//Алгоритм получения последовательности
int SedgewickAlg(int size, int *d)
// d массив, в который заносятся инкременты
// size размерность этого массива
{
  int p1, p2, p3, i;

  p1 = p2 = p3 = 1;
  i = -1;
  do {// заполняем массив элементов по формуле Роберта Седжвика
    if (++i % 2)
      d[i] = 8*p1 - 6*p2 + 1;
	else
	{
      d[i] = 9*p1 - 9*p3 + 1;
      p2 *= 2;
      p3 *= 2;
	}
	p1 *= 2;
	// заполняем массив, пока текущая инкремента хотя бы
	// в 3 раза меньше количества элементов в массиве
  } while(3*d[i] < size);  

  // возвращаем количество элементов в массиве
  return (i > 0) ? (--i) : (0);
  
}

template<class AnyClass>					//Шаблон для использования любого типа данных в массиве
void shellSort(AnyClass *a, int size) {
// inc инкремент, расстояние между элементами сравнения
// i и j стандартные переменные цикла
// d[40] массив, в котором хранятся инкременты
	int inc = 0, d[40];
	int i = 0, j = 0;
	int s = 0;//количество элементов в массиве d[40]

	// вычисление последовательности приращений
	s = SedgewickAlg(size, d);
	while (s >= 0) 
	{
		//извлекаем из массива очередную инкременту
		inc = d[s--];
		
		// сортировка вставками с инкрементами inc
		for (i = inc; i < size; i++) 
		{
			AnyClass temp = a[i];
			// сдвигаем элементы до тех пор, пока не дойдем
			// до конца или не упорядочим в нужном порядке
			for (j = i-inc; (j >= 0) && (a[j] > temp); j -= inc)
				a[j+inc] = a[j];
		// после всех сдвигов ставим на место j+inc элемент, 
		// который находился на i месте
			a[j+inc] = temp;
		}
	}
}

int main()
{
	int n = 0;
	cout<<"Input size of array.\n";
	cin>>n;

	int *a = new int[n];

	cout<<"Input your array.\n";
	for (int i = 0; i < n; i++)
		cin>>a[i];

	shellSort(a, n);

	for (int i = 0; i < n; i++)
		cout<<a[i]<<" ";
	return 0;
}